\echo '\033[1;35m[Helper Queries]\033[0m'
\echo '\033[0;33mDatabase\033[0m:'
\echo '   :conn                 – List of connections'
\echo '   :db_size              – Current DB size with tables and indexes'
\echo '   :db_stats             – Statistics - Includes VACUUM information'
\echo '\033[0;33mTables\033[0m:'
\echo '   :table_size           - Table sizes for the public schema'
\echo '   :bloat                – Space allocated to a relation that is full of dead tuples, that has yet to be reclaimed'
\echo '   :table_stats          – Statistics'
\echo '\033[0;33mQueries\033[0m:'
\echo '   :ps                   – All running queries'
\echo '   :blocks               – Blocked queries'
\echo '   :e_locks              – All queries holding ExclusiveLocks'
\echo '   :slow                 – Slow running queries ( > 5 sec )'
\echo '\033[0;33mIndexes\033[0m:'
\echo '   :index_size           – Size and definition'
\echo '   :index_usage          - Usage'
\echo '   :unused_indexes       - Indexes greater than 5 pages and less than 50 scans'
\echo '   :missing_indexes      - Missing Index?/OK based on # seq scans'
\echo '   :invalid_indexes      - Invalid indexes'
\echo '   :duplicated_indexes   - Duplicated indexes'
\echo '   :seq_scans            - # seq scans per table'
\echo '\033[0;33mCache\033[0m:'
\echo '   :cache_hit            - Hits for DB/Tables/Indexes'
\echo '\033[0;33mSlaves\033[0m:'
\echo '   :slaves               - List of slaves'
\echo

-- Database
\set conn 'SELECT client_addr, usename, COUNT(*), SUM( CASE state when \'idle\'  then 1 else 0 end ) as idle, SUM( CASE state when \'idle in transaction\'  then 1 else 0 end ) as "idle in transaction", SUM( CASE state when \'active\'  then 1 else 0 end ) as active FROM pg_stat_activity GROUP BY client_addr, usename ORDER BY count DESC;'
\set db_size 'SELECT 0 as priority, pg_database.datname AS objectname, \'d\' AS objecttype, 0 :: real AS "#entries", pg_size_pretty(pg_database_size(pg_database.datname)) AS pretty_size, pg_database_size(pg_database.datname) as size FROM pg_database WHERE datname = current_database() UNION SELECT 1 as priority, relname AS objectname, relkind AS objecttype, reltuples AS "#entries", pg_size_pretty(relpages :: bigint * 8 * 1024) AS pretty_size, relpages :: bigint * 8 * 1024 as size FROM pg_class c WHERE relpages >= 8 AND c.relowner = ( SELECT datdba from pg_database WHERE datname = current_database() ) ORDER BY priority, size DESC, "#entries";'
\set db_stats 'SELECT datname, (xact_commit * 100) / (xact_commit + xact_rollback) AS commit_ratio, (xact_rollback * 100) / (xact_commit + xact_rollback) AS rollback_ratio, deadlocks, conflicts, temp_files, pg_size_pretty(pg_database_size(datname)) AS db_size FROM pg_stat_database WHERE xact_commit + xact_rollback != 0 AND datname = current_database();'

-- Tables
\set table_size 'SELECT table_name, pg_size_pretty(table_size) AS table_size, pg_size_pretty(indexes_size) AS indexes_size, pg_size_pretty(total_size) AS total_size FROM ( SELECT table_name, pg_table_size(table_name) AS table_size, pg_indexes_size(table_name) AS indexes_size, pg_total_relation_size(table_name) AS total_size FROM ( SELECT (\'"\' || table_schema || \'"."\' || table_name || \'"\') AS table_name FROM information_schema.tables WHERE table_schema = \'public\') AS all_tables ORDER BY total_size DESC ) AS pretty_sizes ORDER BY pg_total_relation_size(table_name) DESC;'
\set bloat 'SELECT tablename as table_name, ROUND(CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages/otta::numeric END,1) AS table_bloat, CASE WHEN relpages < otta THEN ''0'' ELSE pg_size_pretty((bs*(sml.relpages-otta)::bigint)::bigint) END AS table_waste, iname as index_name, ROUND(CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages/iotta::numeric END,1) AS index_bloat, CASE WHEN ipages < iotta THEN ''0'' ELSE pg_size_pretty((bs*(ipages-iotta))::bigint) END AS index_waste FROM ( SELECT schemaname, tablename, cc.reltuples, cc.relpages, bs, CEIL((cc.reltuples*((datahdr+ma- (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::float)) AS otta, COALESCE(c2.relname,''?'') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages, COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::float)),0) AS iotta FROM ( SELECT ma,bs,schemaname,tablename, (datawidth+(hdr+ma-(case when hdr%ma=0 THEN ma ELSE hdr%ma END)))::numeric AS datahdr, (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2 FROM ( SELECT schemaname, tablename, hdr, ma, bs, SUM((1-null_frac)*avg_width) AS datawidth, MAX(null_frac) AS maxfracsum, hdr+( SELECT 1+COUNT(*)/8 FROM pg_stats s2 WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename) AS nullhdr FROM pg_stats s, ( SELECT (SELECT current_setting(''block_size'')::numeric) AS bs, CASE WHEN substring(v,12,3) IN (''8.0'',''8.1'',''8.2'') THEN 27 ELSE 23 END AS hdr, CASE WHEN v ~ ''mingw32'' THEN 8 ELSE 4 END AS ma FROM (SELECT version() AS v) AS foo) AS constants GROUP BY 1,2,3,4,5) AS foo) AS rs JOIN pg_class cc ON cc.relname = rs.tablename JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname <> ''information_schema'' LEFT JOIN pg_index i ON indrelid = cc.oid LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid WHERE cc.relowner = ( SELECT datdba from pg_database WHERE datname = current_database() )) AS sml ORDER BY CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::bigint END DESC;'
\set tables_stats 'WITH table_opts AS ( SELECT pg_class.oid, relname, nspname, array_to_string(reloptions, \'\') AS relopts FROM pg_class INNER JOIN pg_namespace ns ON relnamespace = ns.oid ), vacuum_settings AS ( SELECT oid, relname, nspname, CASE WHEN relopts LIKE \'%autovacuum_vacuum_threshold%\' THEN substring( relopts, \'.*autovacuum_vacuum_threshold=([0-9.]+).*\' ) :: integer ELSE current_setting(\'autovacuum_vacuum_threshold\') :: integer END AS autovacuum_vacuum_threshold, CASE WHEN relopts LIKE \'%autovacuum_vacuum_scale_factor%\' THEN substring( relopts, \'.*autovacuum_vacuum_scale_factor=([0-9.]+).*\' ) :: real ELSE current_setting(\'autovacuum_vacuum_scale_factor\') :: real END AS autovacuum_vacuum_scale_factor FROM table_opts ) SELECT vacuum_settings.relname AS table, reloptions AS options, to_char(psut.last_vacuum, \'YYYY-MM-DD HH24:MI\') AS last_vacuum, to_char(psut.last_autovacuum, \'YYYY-MM-DD HH24:MI\') AS last_autovacuum, to_char(pg_class.reltuples, \'9G999G999G999\') AS rowcount, to_char(psut.n_dead_tup, \'9G999G999G999\') AS dead_rowcount, to_char( autovacuum_vacuum_threshold + ( autovacuum_vacuum_scale_factor :: numeric * pg_class.reltuples ), \'9G999G999G999\' ) AS autovacuum_threshold, CASE WHEN autovacuum_vacuum_threshold + ( autovacuum_vacuum_scale_factor :: numeric * pg_class.reltuples ) < psut.n_dead_tup THEN \'yes\' END AS expect_autovacuum FROM pg_stat_user_tables psut INNER JOIN pg_class ON psut.relid = pg_class.oid INNER JOIN vacuum_settings ON pg_class.oid = vacuum_settings.oid ORDER BY 1;'

-- Queries
\set ps 'SELECT pid, usename, now() - query_start as duration, state, CASE WHEN wait_event_type = \'Lock\' THEN true ELSE FALSE END as blocked, query FROM pg_stat_activity WHERE query_start IS NOT NULL AND state != \'idle\' ORDER BY duration DESC, blocked;'
\set blocks 'SELECT bl.pid as blocked_pid, kl.pid as blocking_pid, bl.mode as blocked_lock, kl.mode as blocking_lock, bl.transactionid as blocked_transaction_id, kl.transactionid as blocking_transaction_id, now() - a.query_start as blocked_duration, now() - ka.query_start as blocking_duration, a.query as blocked_statement, ka.query as blocking_statement FROM pg_catalog.pg_locks bl JOIN pg_catalog.pg_stat_activity a on bl.pid = a.pid JOIN pg_catalog.pg_locks kl JOIN pg_catalog.pg_stat_activity ka on kl.pid = ka.pid ON bl.transactionid = kl.transactionid AND bl.pid != kl.pid WHERE not bl.granted;'
\set e_locks  'SELECT pg_stat_activity.pid, pg_class.relname, pg_locks.transactionid, pg_locks.mode, pg_locks.locktype, pg_locks.granted, SUBSTRING(pg_stat_activity.query, 1, 50) AS query_snippet, age(now(), pg_stat_activity.query_start) AS duration FROM pg_stat_activity, pg_locks LEFT JOIN pg_class ON (pg_locks.relation = pg_class.oid) WHERE pg_locks.pid = pg_stat_activity.pid AND pg_locks.mode = \'ExclusiveLock\' AND pg_stat_activity.pid != pg_backend_pid() AND pg_stat_activity.query != \'<insufficient privilege>\' ORDER BY query_start;'
\set slow 'SELECT pid, age(now(), pg_stat_activity.query_start) AS duration, query, state FROM pg_stat_activity WHERE state != \'idle\' AND pid != pg_backend_pid() AND datname = current_database() AND now() - pg_stat_activity.query_start > interval ''5 seconds'' ORDER BY now() - pg_stat_activity.query_start DESC;'

-- Indexes
\set index_size 'SELECT i.relname as index_name, t.relname as table_name, i.reltuples AS "entries", pg_size_pretty(i.relpages :: bigint * 8 * 1024) AS size, pg_get_indexdef(ix.indexrelid) AS def from pg_class t INNER JOIN pg_index ix on t.oid = ix.indrelid INNER JOIN pg_class i ON i.oid = ix.indexrelid where t.relkind = \'r\' AND t.relowner = ( SELECT datdba from pg_database WHERE datname = current_database() ) ORDER BY i.relpages DESC;'
\set index_usage 'SELECT * FROM (SELECT stat.relname AS table, stai.indexrelname AS index, CASE stai.idx_scan WHEN 0 THEN ''Insufficient data'' ELSE (100 * stai.idx_scan / (stat.seq_scan + stai.idx_scan))::text || ''%'' END hit_rate, CASE stat.idx_scan WHEN 0 THEN ''Insufficient data'' ELSE (100 * stat.idx_scan / (stat.seq_scan + stat.idx_scan))::text || ''%'' END all_index_hit_rate, ARRAY(SELECT pg_get_indexdef(idx.indexrelid, k + 1, true) FROM generate_subscripts(idx.indkey, 1) AS k ORDER BY k) AS cols, stat.n_live_tup rows_in_table FROM pg_stat_user_indexes AS stai JOIN pg_stat_user_tables AS stat ON stai.relid = stat.relid JOIN pg_index AS idx ON (idx.indexrelid = stai.indexrelid)) AS sub_inner ORDER BY rows_in_table DESC, hit_rate ASC;'
\set unused_indexes 'SELECT relname AS table, indexrelname AS index, pg_size_pretty(pg_relation_size(i.indexrelid)) AS index_size, idx_scan as index_scans FROM pg_stat_user_indexes ui JOIN pg_index i ON ui.indexrelid = i.indexrelid WHERE NOT indisunique AND idx_scan < 50 AND pg_relation_size(relid) > 5 * 8192 AND 0 != ALL (i.indkey) AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_constraint c WHERE c.conindid = ui.indexrelid) ORDER BY pg_relation_size(i.indexrelid) / nullif(idx_scan, 0) DESC NULLS FIRST, pg_relation_size(i.indexrelid) DESC; '
\set missing_indexes 'SELECT relname, seq_scan-idx_scan AS too_much_seq, case when seq_scan-idx_scan > 0 THEN ''Missing Index?'' ELSE ''OK'' END, pg_relation_size(relname::regclass) AS rel_size, seq_scan, idx_scan FROM pg_stat_all_tables WHERE schemaname=''public'' AND pg_relation_size(relname::regclass) > 80000 ORDER BY too_much_seq DESC;'
\set invalid_indexes 'SELECT t.relname AS index_name FROM pg_class t, pg_index idx WHERE idx.indisvalid = false AND idx.indexrelid = t.oid;'
\set duplicated_indexes 'SELECT indrelid :: regclass AS table, ''Exact Match'' AS type, array_agg(indexrelid :: regclass) AS indexes FROM pg_index GROUP BY indrelid, indkey HAVING COUNT(*) > 1 UNION ALL SELECT indrelid :: regclass AS table, ''Partial Match'' AS type, array_agg(indexrelid :: regclass) AS indexes FROM pg_index GROUP BY indrelid, indkey [0] HAVING COUNT(*) > 1 ORDER BY 1 DESC;'
\set seq_scans 'SELECT relname AS name, seq_scan as count FROM pg_stat_user_tables ORDER BY seq_scan DESC;'

-- Cache 
\set cache_hit 'SELECT ''Database Hit Rate'' AS name, SUM(blks_read) AS block_read, SUM(blks_hit) AS block_hit, SUM(blks_hit) / NULLIF(SUM(blks_hit + blks_read),0) AS ratio FROM pg_stat_database WHERE datname = current_database() UNION ALL SELECT ''Index Hit Rate'' AS name, SUM(idx_blks_read) AS block_read, SUM(idx_blks_hit) AS block_hit, SUM(idx_blks_hit) / NULLIF(SUM(idx_blks_hit + idx_blks_read),0) AS ratio FROM pg_statio_user_indexes UNION ALL SELECT ''Table Hit Rate'' AS name, SUM(heap_blks_read) as block_read, SUM(heap_blks_hit) as block_hit, SUM(heap_blks_hit) / NULLIF(SUM(heap_blks_hit + heap_blks_read),0) AS ratio FROM pg_statio_user_tables;'

-- Slaves
\set slaves '(SELECT host(client_addr) as slave, state as state, backend_start as started FROM pg_stat_replication)';